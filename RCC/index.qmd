---
title: "Applied statistics in R"
subtitle: "From zero to practice"
title-slide-attributes:
  data-background-image: img/background-mucss.webp
  data-background-size: cover
  data-background-opacity: "0.2"
author: "Course at Real Colegio Complutense at Harvard University ‚Ä¢ Javier √Ålvarez Li√©bana"
affiliation: Technical University of Madrid (UPM)
lang: en-US
format: 
  revealjs:
    embed-resources: true
    theme: [default, style.scss]
    menu:
      side: left
      width: normal
    footer: "[<strong>Javier √Ålvarez Li√©bana</strong>](...) ‚Ä¢ Course at Real Colegio Complutense at Harvard University"
    slide-number: c/t
execute:
  echo: true
---


## Hi!

[**Mail**]{.hl-green}: **<javier.alvarez.liebana@upm.es>**.

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
-   [**Javier √Ålvarez Li√©bana**]{.hl-yellow} from Carabanchel (Madrid).

-   Degree in Mathematics (UCM). [**PhD in Statistics**]{.hl-yellow} (UGR).

-   [**Data visualization and analysis**]{.hl-yellow} for the Principality of Asturias (2021-2022) during the COVID pandemic

-   Member of the [**Spanish Society of Statistics and OR**]{.hl-yellow} and the [**Spanish Royal Mathematical Society**]{.hl-yellow}.


:::
:::
:::


Currently, [**Assistant Professor at Technical University of Madrid (UPM)**]{.hl-yellow} and [**Visiting Researcher at Harvard University**]{.hl-yellow}.


---

## Goals

::: columns
::: {.column width="37%"}
![](https://assets-global.website-files.com/6092cb6b4ac959f39728dd26/6188a97fa499b5fbfe410417_target%20(1).png)
:::

::: {.column width="63%"}
::: incremental
- Take away the [**fear of programming**]{.hl-yellow} ‚Üí learn to program by programming

- Understanding [**basic R concepts**]{.hl-yellow} from scratch ‚Üí learning to **abstract** ideas and algorithms

- Utility of programming ‚Üí [**reproducible, transparent and maintainable workflows**]{.hl-yellow}.

- Introduction to [**analysis and preprocessing of data**]{.hl-yellow} ‚Üí `{tidyverse}`.

- Introduction to [**dataviz in R**]{.hl-yellow} ‚Üí `{ggplot2}`

- To learn the [**fundamentals of statistics and Machine Learning**]{.hl-yellow}. From descriptive analysis to prediction: building our first models.


:::
:::
:::


---

## Planning: intro R {#planificacion}

::: column-screen-inset-right
::: {style="font-size:20px"}
|  LESSON | WEEK | DATES | TOPIC | EX. | WORKBOOK | TASK | 
|:------:|:--------:|:--------:|:------:|:------:|:------:|:------:|:------:|:------:|:------:|
| [1-1](#clase-0-1) | S1 | 17 feb | First steps: R base programming | [üíª](#tu-turno-0-1-1) [üíª](#tu-turno-0-1-2)  |  |  | 
| [1-2](#clase-0-2) | S1 | 19 feb | First data: concatenate values and databases | [üíª](#tu-turno-0-2-1) [üíª](#tu-turno-0-2-2) [üíª](#tu-turno-0-2-3) |  [üê£](#caso-practico-0-2-1) [üê£](#caso-practico-0-2-2) [üê£](#caso-practico-0-2-3) |  |
| [1-3](#clase-0-3) | S2 | 24 feb | Welcome to tidyverse! |  [üíª](#tu-turno-3-1) [üíª](#tu-turno-3-2) |   |  |
:::
:::


---

## Materials

* [**Slides**]{.hl-yellow}: slides made with `Quarto`. In the slide menu (bottom left) you have an option to  [**download them in pdf**]{.hl-yellow} in `Tools`

&nbsp;

* [**Material**]{.hl-yellow}:
  - **workbooks** contained in `workbooks` folder.
  - **cheatsheets of packages** contained in `cheatsheets-packages` folder.
  
<!---
* [üóÉ **Data**]{.hl-yellow}: datasets that will be used, available on **<https://javieralvarezliebana.es/docencia/mucss-data-programming/material>** or **Google Drive** <https://drive.google.com/drive/folders/18Ok6Epqcimszqguj_JTTLuSbs5Ot5Srd?usp=sharing>
--->

* [üìö **Extra resources**]{.hl-yellow}:  <https://r4ds.had.co.nz/>, <https://cdr-book.github.io/> and <https://ivelasq.quarto.pub/intro-to-quarto/>.


# L1: [first steps in R]{.flow} {#clase-0-1}



[**Introduction to R and RStudio. Working with projects. First uses of functions and packages. Basic data types**]{style="color:#444442;"}

* [üíª Solved exercises: first steps](#tu-turno-0-1-1)
* [üíª Solved exercises: first variables](#tu-turno-0-1-2)
* [üìÜ Planning](#planificacion)

---

## Requirements

For the course, the only requirements will be:

1. [**Internet connection**]{.hl-yellow} (to download some data and packages).

. . .

2. [**Install R**]{.hl-yellow}: it will be our language. We will download it (for free) from <https://cran.r-project.org/>

. . .

3. [**Install RStudio**]{.hl-yellow} from <https://posit.co/download/rstudio-desktop/>

::: columns
::: {.column width="50%"}

![](img/cranR.jpg){width="420"}

:::


::: {.column width="50%"}

![](img/rstudio.jpg){width="420"}

:::
:::

---

## R vs RStudio

::: columns
::: {.column width="50%"}
![](img/gramatica.webp){width="360"}
:::

::: {.column width="50%"}
![](img/word.jpg){width="430"}
:::
:::


::: {.fragment .fade-in-then-out}

We will program as we write 

:::

::: {.fragment .fade-up}

-   We will need a [**grammar, a language**]{.hl-yellow} (`R`)

::: {.fragment .fade-in}

-   And an environment, such as [**Word**]{.hl-yellow} (`RStudio`) to write it

:::
:::

---

## Installing R

The `R` language will be our [**grammar and spelling**]{.hl-yellow} (our rules of the game)


::: incremental
-   [**Step 1**]{.hl-yellow}: go to <https://cran.r-project.org/> and select your operating system.

-   [**Step 2**]{.hl-yellow}: for Mac, simply click on the **.pkg file**, and open it once downloaded. For Windows systems, we need to click on **install R for the first time** and then on **Download R for Windows**. Once downloaded, open it like any installation file.

-   [**Step 3**]{.hl-yellow}: open the installation executable.

:::

. . .

::: callout-warning

Whenever you need to download something from CRAN (either `R` itself or a package), [**make sure you have an internet connection**]{.hl-orange}.

:::

---

## First operation {auto-animate="true"}

::: columns
::: {.column width="60%"}

To check the installation, after opening `R`, you should see the `R GUI` (Graphical User Interface) with a **white screen** similar to this ([**console**]{.hl-yellow}).

:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

. . .

[**First code**]{.hl-yellow}: we will **assign** the value `1` to a variable called `a` (we will write the code in the console and press "enter"). Then we will do the sum `a + b`.

```{r}
#| code-line-numbers: "1"
a <- 1
```

---

## First operation {auto-animate="true"}

::: columns
::: {.column width="60%"}

To check the installation, after opening `R`, you should see the `R GUI` (Graphical User Interface) with a **white screen** similar to this ([**console**]{.hl-yellow}).

:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**First code**]{.hl-yellow}: we will **assign** the value `1` to a variable called `a` (we will write the code in the console and press "enter"). Then we will do the sum `a + b`.

```{r}
#| code-line-numbers: "2"
a <- 1
b <- 2
```

---

## First operation {auto-animate="true"}

::: columns
::: {.column width="60%"}

To check the installation, after opening `R`, you should see the `R GUI` (Graphical User Interface) with a **white screen** similar to this ([**console**]{.hl-yellow}).

:::

::: {.column width="40%"}
![](img/consola.jpg){width="200"}
:::
:::

[**First code**]{.hl-yellow}: we will **assign** the value `1` to a variable called `a` (we will write the code in the console and press "enter"). Then we will do the sum `a + b`.

```{r}
#| code-line-numbers: "3"
a <- 1
b <- 2
a + b
```

. . .

::: callout-note
## Note that...

In the console, a number `[1]` appears: it's simply an element counter (like counting rows in Word)

:::

---

## Installing R Studio

`RStudio` will be the [**Word**]{.hl-yellow} we will use to write (what is known as an [**IDE: Integrated Development Environment**]{.hl-yellow}).

::: incremental
-   [**Step 1**]{.hl-yellow}: go to the [official RStudio website](https://posit.co/download/rstudio-desktop/) (now called Posit) and select the free download.

-   [**Step 2**]{.hl-yellow}: select the executable that appears according to your operating system.

-   [**Step 3**]{.hl-yellow}: after downloading the executable, open it like any other and let the installation finish.

:::

---

## RStudio Organization

When you open `RStudio` you will likely have three windows:


-   [**Console**]{.hl-yellow}: is the name for the large window that takes up most of your screen. Try writing the same code as before (the sum of the variables) in it. The console is where **we will execute commands and display results**.

![](img/consola_rstudio.jpg){width="420"}

---

## RStudio Organization

When you open `RStudio` you will likely have three windows:

-   [**Environment**]{.hl-yellow}: the small screen (you can adjust the margins with the mouse to your liking) that we have in the top right corner. It will show us the **variables we have defined**.


![](img/environment.jpg){width="420"}

---

## RStudio Organization

When you open `RStudio` you will likely have three windows:

-   [**Multi-purpose panel**]{.hl-yellow}: the window at the bottom right will be used to **look for function help**, as well as to **visualize plots**.

![](img/multiusos.jpg){width="420"}

---

## What is R? Why R?

![](img/meme_barco.jpg)

---


## What is R? Why R?

![](img/incel_excel.png)

`R` is the evolution of the work of Bell Laboratories with the `S` language, which was brought into the open-source world by Ross Ihaka and Robert Gentleman in the 1990s. The version `R 1.0.0` was released on February 29, 2000.


---

## What is R? Why R?

`R` is the [**statistical language par excellence**]{.hl-yellow}, created by and for statisticians, with 6 fundamental advantages [**over Excel, SAS, Stata, or SPSS**]{.hl-red}:

. . .

-   [**Programming language**]{.hl-yellow}: the obvious ‚Üí [**replicable**]{.hl-purple} analysis

. . .

-   [**Free**]{.hl-yellow}: the philosophy of the `R` community is to share code under **copyleft** ‚Üí **ethical use of spending and algorithms**

. . .

-   [**Open-source software**]{.hl-yellow}: not only is it free, but it also allows free access to others' code, even to the **source code itself** ‚Üí [**flexibility and transparency**]{.hl-purple} (Free and Open Source Software FOSS)

---

## What is R? Why R?

`R` is the [**statistical language par excellence**]{.hl-yellow}, created by and for statisticians, with 6 fundamental advantages [**over Excel, SAS, Stata, or SPSS**]{.hl-red}:


-   [**Modular language**]{.hl-yellow}: we have installed the minimum, but there are codes from other people that we can reuse (almost 20,000 [**packages**]{.hl-yellow}) ‚Üí [**time saving**]{.hl-purple} and [**immediate innovation**]{.hl-purple}

. . .

-   [**High-level language**]{.hl-yellow}: facilitates programming (like Python) ‚Üí [**lower learning curve**]{.hl-purple}

. . .

- [**Community and employability**]{.hl-yellow}

---

## Why programming?

-   [**Automate**]{.hl-yellow} ‚Üí it will allow you to automate recurring tasks.

-   [**Replicability**]{.hl-yellow} ‚Üí you will be able to replicate your analysis in the same way every time.

-   [**Flexibility**]{.hl-yellow} ‚Üí you will be able to adapt the software to your needs.

-   [**Transparency**]{.hl-yellow} ‚Üí to be audited by the community.

![](img/the_general_problem.png)

---

## Fundamental Idea: Packages

One of the key ideas of `R` is the [**use of packages**]{.hl-yellow}: codes that other people have implemented to **solve a problem**


::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}

-   [**Installation**]{.hl-yellow}: we download the codes from the web (we need internet) ‚Üí [**buy a book**]{.hl-purple}, only once (per computer)


```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}

-   [**Loading**]{.hl-yellow}: with the package downloaded, we indicate which packages we want to use each time we open `RStudio` ‚Üí [**take the book off the shelf**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```

:::
:::
:::

---

## Fundamental Idea: Packages

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}

Once installed, there are **two ways to use a package** (take it off the shelf)

::: {.fragment fragment-index="1"}

-   [**Whole package**]{.hl-yellow}: with `library()`, using the package name without quotes, we load [**the whole book**]{.hl-purple} into the session


```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}

-   [**Specific functions**]{.hl-yellow} using `package::function+  we indicate that we only want [**a specific page of that book**]{.hl-purple}


```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## You will be wrong

During your learning, it will be very common for things not to work out on the first try ‚Üí [**you will be wrong**]{.hl-yellow}. It will not only be important to accept it but also [**to read the error messages**]{.hl-yellow} to learn from them.


. . .

-   [**Error messages**]{.hl-red}: preceded by **"Error in..."** and will be those failures that [**prevent execution**]{.hl-red}

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Warning messages**]{.hl-orange}: preceded by **¬´Warning in...¬ª** they are the (possible) more delicate errors as they are inconsistencies that [**do not prevent execution**]{.hl-orange}


```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```

---

## Scripts (.R files)


::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}

A [**script**]{.hl-yellow} will be the document in which we program, our `.doc` file (here with a `.R` extension) where we will write the commands. To **open our first script**, click on the menu in `File < New File < R Script`.


::: callout-warning
## Be careful

It's important **not to overuse the console**: everything you don't write in a script, when you close, [**will be lost**]{.hl-orange}.

:::

:::
:::



::: callout-warning
## Be careful

`R` is [**case-sensitive**]{.hl-orange}: it is sensitive to uppercase and lowercase, so `x` and `X` represent different variables.

:::


---

## Running the first script

Now we have a **fourth window**: the window where we will [**write our codes**]{.hl-yellow}. How do we run it?

. . .

1. **Write the code** to be executed.

. . .

2. **Save the .R file** by clicking on `Save current document`.

. . .

3. The code does not execute unless we indicate it. We have **three options to run a script**:

- [**Copy and paste**]{.hl-yellow} into the console.
- [**Select lines**]{.hl-yellow} and press `Ctrl+Enter`
- [**Enable Source on Save**]{.hl-yellow} next to save: not only saves but also executes the **entire code**.

---


## Organizing: projects

Just as we usually work [**organized by folders**]{.hl-yellow} on the computer, in `RStudio` we can do the same to work [**efficiently by creating projects**]{.hl-yellow}.

. . .

::: columns
::: {.column width="60%"}

A [**project will be a "folder"**]{.hl-yellow} within `RStudio`, so our root directory will automatically be the project folder itself (allowing us to switch from one project to another using the top right menu).

We can create one in a new folder or in an existing folder."

:::

::: {.column width="40%"}
![](img/rstudio_proyectos.png){width="370"}
:::
:::


---

## üíª It's your turn {#tu-turno-0-1-1}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

üìù Create a **course folder** on your computer and **set up an RStudio Project inside it**. This will serve as your working directory for the entire course. After creating the project, you will see an .Rproj file. Within this folder, create two subfolders: data (for datasets) and scripts (for the .R files from each session).

### [**Exercise 2**]{.hl-yellow}

üìù Inside the project create a script `Exercises-class1.R` (inside the `scripts` folder). Once created, define in it a variable named `a` and whose value is -1. Execute the code as you want

```{r}
#| code-fold: true
a <- -1
```

### [**Exercise 3**]{.hl-yellow}

üìù Add below another line to define a variable `b` with the value 5. Then save the multiplication of both variables. Execute the code as you want.

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # without saving it
mult <- a * b # save it
```

### [**Exercise 4**]{.hl-yellow}

üìù Modify the code below to define two variables c and d, with values 3 and -1. Then divide the variables and save the result.

```{r}
#| eval: false
c <- # you should assign 3
d <- # you should assign -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d
div <- c / d
```

### [**Exercise 5**]{.hl-yellow}

üìù Assign to `x` a positive value and then compute its square root; assign to `y` a negative number and compute its absolute value using `abs()`.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

::: callout-note
## Note that...

Commands like `sqrt()`, `abs()` or `max()` are what we call [**functions**]{.hl-purple}: lines of code that we have "encapsulated" under a name, and given some input arguments, execute the commands (a sort of shortcut). In the functions the [**arguments will ALWAYS be enclosed in parentheses**]{.hl-yellow}

:::


### [**Exercise 6**]{.hl-yellow}

üìù Using the variable `x` already defined, complete/modify the code below to store in a new variable `z` the result stored in `x` minus 5.

```{r}
#| eval: false
z <- ? - ? # complete the code
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```

### [**Exercise 7**]{.hl-yellow}

üìù Define an `x` variable and assign it the value `-1`. Define another `y` and assign it the value `0`. Then perform the operations a) `x` by `y`; b) square root of `x`. What do you get?


```{r}
#| code-fold: true
#| eval: false
x <- -1
y <- 0

x / y
sqrt(x)
```

### [**Exercise 8**]{.hl-yellow}

üìù Write the code below in your script. Why do you think it doesn't work?

```{r}
#| error: true
x <- -1
y <- 0

X + y
```

:::



---

## From CELL to TABLE

What [**data type**]{.hl-yellow} can we have in each **cell of a table**?



![](img/celdas.jpg)

::: incremental

- [**Cell**]{.hl-yellow}: an individual piece of data of a specific type.
- [**Variable**]{.hl-yellow}: **concatenation** of values of the same type ([**vectors in R**]{.hl-purple}).
- [**Matrix**]{.hl-yellow}: concatenation of variables of the **same type and length**.
- [**Table**]{.hl-yellow}: concatenation of variables of [**different types but the same length**]{.hl-purple}
- [**List**]{.hl-yellow}: concatenation of variables of [**different types and different lengths**]{.hl-purple}
:::

---

## But first...best practices

Before we continue, it‚Äôs important to know something as soon as possible: [**starting with programming can be frustrating**]{.hl-yellow}

. . .

Just like when learning a new language, the first obstacle is not so much what to say but how to say it correctly. The same goes for `R`, so let‚Äôs [**standardize our programming style**]{.hl-yellow} as much as possible to avoid future errors.

. . .

* [**Tip 1**]{.hl-green}: [**assignment, evaluation, and comparison are not the same**]{.hl-yellow}. If you‚Äôve noticed in `R`, we use `<-` to assign values to variables. We use `=` to evaluate function arguments and `==` to check if two elements are equal.

```{r}
#| eval: false
x <- 1 # asign
x = 1 # evaluation
x == 1 # comparison
```



---

## But first...best practices

* [**Tip 2**]{.hl-green}: program like you write. Just like when writing in Spanish, get used to incorporating [**spaces and line breaks**]{.hl-yellow} to avoid making your code hard to read (it's a good practice, not a requirement, because `R` does not process spaces).


```{r}
#| eval: false
x <- 1 # optimal
x<-1 # meh
x<- 1 # worst (make up your mind)
```

. . .

* [**Tip 3**]{.hl-green}: don‚Äôt be chaotic, [**standardize names**]{.hl-yellow}. Always get used to naming variables consistently. The only requirement is that **they must always start with a letter** (and without accents). The most recommended form is `snake_case`.



```{r}
#| eval: false
variable_in_snake_case
anotherHarderToReadFormat
there.are.people.who.use.this
Even_People_Here.Confusing_That_Do_Not_Deserve_Our_ATTENTION
```

---

## But first...best practices

* [**Tip 4**]{.hl-green}: make reading and writing easier, [**set limits**]{.hl-yellow}. In `Tools < Global Options`, you can customize some options in `RStudio`. In `Code < Display`, you can set `Show margin` to display an "imaginary" margin (not interacting with the code) to "force" you to make line breaks.

![](img/show_margin.jpg)


---

## But first...best practices

* [**Tip 5**]{.hl-green}: the [**tab key is your best friend**]{.hl-yellow}. In `RStudio`, there‚Äôs a wonderful tool: if you type part of a variable or function name and press tab, `RStudio` will autocomplete it for you.


![](img/tab-autocompletar.png)  


---

## But first...best practices

* [**Tip 6**]{.hl-green}: no single parentheses. Whenever you open a parenthesis, you must close it. To make this task easier, go to `Tools < Global Options < Code < Display` and enable the `Rainbow parentheses option`.

![](img/rainbow-parentheses.jpg)



---

## But first...best practices

* [**Tip 7**]{.hl-green}: pay attention to the left side. You will not only see the line of code you are on but also, in case of a [**syntax error**]{.hl-red}, `RStudio` will notify you.

![](img/rstudio-error-sintaxis.png)

* [**Tip 8**]{.hl-green}: try to [**always work by projects**]{.hl-yellow} (for this class, create a script `class1.R` in the project we created before)


&nbsp;

See more tips at <https://r4ds.had.co.nz/workflow-basics.html#whats-in-a-name>

---

## Cells: data types

Are there [**variables beyond numbers in data science**]{.hl-yellow}? For example, think about the data you might store about a person:


::: {.fragment .fade-up}
-  Age or weight will be a [**number**]{.hl-yellow}.

```{r}
age <- 33
```
:::

::: {.fragment .fade-up}
- Their name will be a string of [**text (known as string or char)**]{.hl-yellow}.

```{r}
name <- "javi"
```

:::

::: {.fragment .fade-up}
-   The answer to the question "Are you enrolled in the Faculty?" will be what we call a [**logical variable**]{.hl-yellow} (`TRUE` if enrolled or `FALSE` otherwise).


```{r}
enrolled <- TRUE
```
:::

::: {.fragment .fade-up}
-   Their date of birth will be precisely that, a [**date**]{.hl-yellow}.
:::

---

## Numerical variables {auto-animate="true"}

The simplest data (which we‚Äôve already used) will be [**numeric variables**]{.hl-yellow}. To find out the [**data class in R**]{.hl-yellow} of a variable, we use the `class()` function.


```{r}
#| eval: false
#| code-line-numbers: "1"
a <- 5
```

---

## Numerical variables {auto-animate="true"}

The simplest data type (we have already used it) will be the [**numeric variables**]{.hl-yellow}. To know the [**data class in R**]{.hl-yellow} of a variable we have the function `class()`.


```{r}
#| eval: false
#| code-line-numbers: "2"
a <- 5
class(a)
```

. . .

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

To know its [**typology (format)**]{.hl-yellow} variable we have `typeof()`.

```{r}
typeof(1) # 1 value but stored as a real number (double precision)
typeof(as.integer(1)) # 1 value but stored as a floor number
```

::: callout-note
## Note that...

In `R` we have a collection of functions starting with `as.x()` that serve as [**conversion functions**]{.hl-yellow}: a data that was of one type, we convert it to type `x`.
:::

---


## Numerical variables

In addition to the "common" numbers we will have the [**plus/minus infinity**]{.hl-yellow} coded as `Inf` or `-Inf`.

```{r}
1/0
```

```{r}
-1/0
```

. . .

And values that [**are not real numbers**]{.hl-yellow} _not a number_ (indeterminacies, complexes numbers, etc) encoded as `NaN`.

```{r}
0/0
```

```{r}
sqrt(-2)
```



---

## Numerical variables

With numeric variables we can perform the [**arithmetic operations**]{.hl-yellow} of a calculator: adding (`+`)...

```{r}
a + b
```

. . .

...square root (`sqrt()`)...

```{r}
sqrt(a)
```

. . .

... power (`^2`, `^3`)...

```{r}
a^2
```

. . .

...absolute value (`abs()`), etc.

```{r}
abs(a)
```


---

## String variables

Let us imagine that, in addition to the age of a person we want to store his/her name: now the variable will be of type `character`.

```{r}
name <- "Javi"
class(name)
```

. . .

The [**text strings**]{.hl-yellow} are a type with which we obviously [**cannot perform arithmetic operations**]{.hl-red} (other operations such as pasting or locating patterns can be performed).

```{r}
#| error: true
name + 1 # error when we try to sum 1 to a text
```

. . .

::: callout-warning
## Reminder

Text variables (character or string) are [**ALWAYS in quotes**]{.hl-orange}: `TRUE` (logical, binary value) is not the same as `"TRUE"` (text).

:::

---

## First function: paste

As we have commented `R` we will call [**function**]{.hl-yellow} a piece of [**encapsulated code**]{.hl-yellow} under a name, and which depends on some input [**arguments**]{.hl-yellow}. Our first function will be `paste()`: given two strings, it allows us to paste them together.

```{r}
paste("Javi", "√Ålvarez")
```

. . .

Note that [**default**]{.hl-yellow} pastes strings with a space, but we can add an [**optional argument**]{.hl-yellow} to tell it the separator (in `sep = ...`). 

```{r}
paste("Javi", "√Ålvarez", sep = "*")
```

. . .

Remember that functions are always as `name_of_function(arguments)`, whereas we will use `[i]` to access to i-th element.

---

## First function: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}

How do I know [**what arguments does a function need**]{.hl-yellow}?

By typing `? paste` in the console, you will get a [**help**]{.hl-yellow} in the multipurpose panel, where you can see in its header what arguments the function already has [**default arguments**]{.hl-yellow} assigned to it.

:::
:::

. . .

There is a similar function called `paste0()` that pastes by default with `sep = ‚Äú‚Äù` (without anything).

```{r}
paste0("Javi", "√Ålvarez")
```

---

## First function: paste

The arguments (and their detail) can also be consulted by **tabulating (after a comma)**.

![](img/tab-functions.png)

--- 

## Functions: default arguments

It is very important to understand the concept of [**default argument of a function**]{.hl-yellow} in `R`: it is a value that the function uses but sometimes we may not see because [**already has a value assigned**]{.hl-yellow}. 
```{r}
# Same
paste("Javi", "√Ålvarez")
paste("Javi", "√Ålvarez", sep = " ")
```

. . .

::: callout-note

The `=` operator is [**reserved for assigning arguments**]{.hl-yellow} within functions. For all other assignments, we will use `<-`.

:::

---

## First package: glue

A more intuitive way to work with text is to use the `{glue}` package: the first thing to do is to "buy the book" (if we have never done it before). After that [**load the package**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue") # just the first time
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

With the `glue()` function of that package we can use [**variables inside strings**]{.hl-yellow}. For example, "age is ... years old", where the age is stored in a variable.

```{r}
age <- 34
glue("I am {age} old")
```

. . .

Within the keys we can also [**execute operations**]{.hl-yellow}

```{r}
units <- "days"
glue("I am {age * 365} {units} old")
```

---

## Logical variables

Another fundamental type will be the [**logical or binary variables**]{.hl-yellow} (**two values**):

- `TRUE`: [**true**]{.hl-yellow} stored internally as a 1.

- `FALSE`: [**false**]{.hl-yellow} stored internally as a 0.

```{r}
single <- FALSE # Single? --> NO
class(single)
```

. . .

Since they are stored internally as binary variables, we can [**perform arithmetic operations**]{.hl-yellow} on them


```{r}
2 * TRUE
FALSE - 1
```

---

## Logical variables

As we will see shortly, logical variables can actually take a third value: `NA` or [**missing data**]{.hl-yellow}, representing *not available*, and it will be very common to find it within a database.

```{r}
missing <- NA
missing + 1
```


. . .

::: callout-important
## Important

Logical variables [**NOT text variables**]{.hl-red}: `"TRUE"` is a text, `TRUE` is a logical value.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Logical conditions

Logical values are usually the result of [**evaluate logical conditions**]{.hl-yellow}. For example, imagine that we want to [**check**]{.hl-yellow} whether a person is named Javi.


```{r}
name <- "Mar√≠a"
```


. . .

With the [**logical operator**]{.hl-yellow} `==` we ask if what we have stored on the left is [**same as**]{.hl-purple} what we have on the right: [**we ASK**]{.hl-yellow}

```{r}
name == "Javi"
```

. . .

With its opposite `!=` we ask [**if different**]{.hl-purple}.

```{r}
name != "Javi"
```

. . .

::: callout-note
## Note that...

It is not the same `<-` ([**assignment**]{.hl-yellow}) as `==` (we are [**asking**]{.hl-yellow}, it is a logical comparison).

:::

---

## Logical conditions

In addition to "equal to" versus "different" comparisons, also order comparisons such as [**less than**]{.hl-purple} `<`, [**greater than**]{.hl-purple} `>`, `<=` or `>=`.
**Is the person less than 32 years old?**

```{r}
age <- 34
age < 32 # less than 32 years old?
```

. . .

**Age is greater than or equal to 38 years?**

```{r}
age >= 38
```

. . .

**Is the saved name equal to Javi?**

```{r}
name <- "Javi"
name == "Javi"
```

---

## Date variables

A very special data type: the [**date type data**]{.hl-yellow}.

```{r}
date_char <- "2021-04-21"
```

It looks like a simple text string but [**should represent an instant in time**]{.hl-yellow}. What should happen if [**we add a 1 to a date**]{.hl-purple}?

. . .

```{r}
#| error: true
date_char + 1
```


Dates [**cannot be string/text**]{.hl-red}: we must convert the text string to date.

. . .

&nbsp;

To work with dates we will use the `{lubridate}` package, which we must install before we can use it.

```{r}
#| eval: false
install.packages("lubridate")
```

---

## Date variables

Once installed, of all the packages (books) that we have, we will indicate it to load this one concretely.

```{r}
library(lubridate) 
```

. . .

To [**convert to date type**]{.hl-yellow} we will use the `as_date()` function of the `{lubridate}` package (default in `yyyy-mm-dd` format).


&nbsp;

:::: columns
::: {.column width="50%"}

```{r}
#| error: true

# it's not a date, it's a text!
date_char + 1
class(date_char)
```

:::

::: {.column width="50%"}

```{r}
date <- as_date("2023-03-28")
date + 1
class(date)
```

:::

::::

---

## Date variables

In `as_date()` the default date format is `yyyy-mm-dd` so if the string is not entered correctly...

```{r}
as_date("28-08-2024")
```

. . .

For [**any other format we must specify it**]{.hl-yellow} in the optional argument `format = ...` such that `%d` represents days, `%m` months, `%Y` in 4-year format and `%y` in 2-year format.


```{r}
as_date("28-03-2023", format = "%d-%m-%Y")
as_date("28-03-23", format = "%d-%m-%y")
as_date("03-28-2023", format = "%m-%d-%Y")
as_date("28/03/2023", format = "%d/%m/%Y")
```


---

## Date variables

In this package we have very useful functions for [**date management**]{.hl-yellow}:

- With `today()` we can directly obtain the [**current date**]{.hl-purple}.

```{r}
today()
```

. . .

-  With `now()` we can obtain [**current date and time**]{.hl-purple}

```{r}
now()
```

. . .

- With `year()`, `month()` or `day()` we can [**extract year, month and day**]{.hl-purple}

```{r}
date_today <- today()
year(date_today)
month(date_today)
```

---

## Cheatsheets

![](img/lubridate.png)

::: callout-note
## More information

You have a pdf summary of the most important packages in the [**corresponding folder on campus**]{.hl-green}

:::

---

## üíª It's your turn {#tu-turno-0-1-2}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

üìù Define a variable that stores your age (called `age`) and another with your name (called `name`).

```{r}
#| code-fold: true
age <- 34
name <- "Javi"
```

### [**Exercise 2**]{.hl-yellow}

üìù Check with this variable `age` if it is NOT 60 years old or if it is called `"Ornitorrinco"` (you must obtain logical variables as a result).

```{r}
#| code-fold: true
#| eval: false
age != 60 # different to
name == "Ornitorrinco" # equal to
```

### [**Exercise 3**]{.hl-yellow}

üìù Why does the lower code not produce an error?

```{r}
#| error: true
age + name
```


### [**Exercise 4**]{.hl-yellow}

üìù Define another variable called `siblings` that answers the question "do you have siblings?" and another variable that stores your date of birth (called `birth_date`).

```{r}
#| code-fold: true
siblings <- TRUE

library(lubridate) # if not before
birth_date <- as_date("1989-09-10")
```

### [**Exercise 5**]{.hl-yellow}

üìù Define another variable with your last name (called `surname`) and use `glue()` to have, in a single variable called `full_name`, your first and last name separated by a comma.

```{r}
#| code-fold: true
#| eval: false
surname <- "√Ålvarez Li√©bana"
full_name <- glue("{name}, {surname}")
full_name
```

### [**Exercise 6**]{.hl-yellow}

üìù From `birth_date` extract the month.

```{r}
#| code-fold: true
#| eval: false
month(birth_date)
```

### [**Exercise 7**]{.hl-yellow}

üìù Calculate the days that have passed since your birth date until today (with the birth date defined in Exercise 4).

```{r}
#| code-fold: true
#| eval: false
today() - birth_date
```

### [**Exercise 8**]{.hl-yellow}

üìù Why does the lower code give an error?

```{r}
#| error: true
paste["javier", "√°lvarez"]
```

### [**Exercise 9**]{.hl-yellow}

üìù Why does the lower code not produce an error?

```{r}
#| error: true
"TRUE" + 1
```

### [**Exercise 10**]{.hl-yellow}

üìù What do you think it is stored in the variable "healthy" below?

```{r}
#| eval: false
colestherol <- 140
systolic_blood_pressure <- 16
healthy <- colestherol <= 200 & systolic_blood_pressure <= 14
```

### [**Exercise 11**]{.hl-yellow}

üìù Why does the lower code not produce an error?

```{r}
#| error: true
nombre <- "javi"
(nombre == "javi") + 1
```

:::



# L2 : [databases]{.flow} {#clase-0-2}

[**Concatenating cells: vectors. First databases**]{style="color:#444442;"}

* [üíª Solved exercises: vectors](#tu-turno-0-2-1) 

* [üíª Solved exercises: data.frame and tibble](#tu-turno-0-2-3) 

* [üê£ Workbook/case study I-II](#caso-practico-0-2-1)

* [üìÜ Planning](#planificacion)

---

## Vectors: concatenation

When working with data, we often have [**columns that represent variables**]{.hl-yellow}: we will refer to these as [**vectors**]{.hl-yellow}, which are a [**concatenation**]{.hl-purple} of cells (values) of the [**same type**]{.hl-purple} (similar to a column in a table).

. . .

The simplest way to create a vector is with the `c()` function (c stands for **concatenate**), and you just need to input the **elements within parentheses, separated by commas**.

```{r}
ages <- c(32, 27, 60, 61)
ages
```

. . .

::: callout-tip

An individual number `x <- 1` (or `x <- c(1)`) is actually a **vector of length one** --> everything we know how to [**do with a number, we can do with a vector of numbers**]{.hl-green}.

:::

---

## Vectors: concatenation

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}

As you can see now in the `environment`, we have a **collection of elements** stored.


```{r}
ages # ages = edades in spanish
```
:::
:::

. . .


The [**length of a vector**]{.hl-yellow} can be calculated with `length()`.


```{r}
length(ages)
```

. . .

We can also [**concatenate vectors**]{.hl-yellow} together (it repeats them one after another).

```{r}
c(ages, ages, 8)
```

---

## Numeric sequences

The most common type of vector is numeric, specifically, the well-known [**numeric sequences**]{.hl-yellow} (e.g., the days of the month), used among other things, to index loops.

. . .

The `seq(start, end)` function allows us to create a [**numeric sequence]**{.hl-yellow} from a starting element to an ending one, [**advancing one by one**]{.hl-purple}.


```{r}
seq(1, 31)
```

. . .

Note that if we try this with [**characters, it won't work**]{.hl-red} since there is no predefined order among text strings.

```{r}
#| error: true
"a":"z"
```

---

## Numeric sequences

A shortcut is the `1:n` command, which returns the same as `seq(1, n)`.


```{r}
1:7
```

If the starting element is greater than the ending one, it understands that the sequence is in [**descending order**]{.hl-purple}.

```{r}
7:-3
```

. . .

We can also define [**a different step**]{.hl-yellow} between consecutive elements with the `by = ...` argument.


```{r}
seq(1, 7, by = 0.5) # seq from 1 to 7, with a step of 0.5
```

---

## Numeric sequences

Sometimes we may want to define a [**sequence with a specific length**]{.hl-yellow}.


```{r}
seq(1, 50, l = 7) # seq from 1 to 50 with length equal to 7
```

. . .

We might also want to generate a vector of [**n repeated elements**]{.hl-yellow}.

```{r}
rep(0, 7) # vector of 7 0's
```

. . .

Since they are internally stored as numbers, we can also do this with [**dates**]{.hl-yellow}.


```{r}
seq(as_date("2023-09-01"), as_date("2023-09-10"), by = 1)
```


---

## String vectors

A vector is a **concatenation** of elements of the [**same type**]{.hl-yellow}, but they don't necessarily have to be numbers. Let's create a sample sentence.

```{r}
sentence <- "My name is Javi"
sentence
length(sentence)
```

. . .

In the previous case, it wasn't a vector, it was a single text element. To create a vector, we need to use `c()` again and separate elements with commas.


```{r}
sentence <- c("My", "name", "is", "Javi")
sentence
length(sentence)
```

---

## String vectors

What will happen if we [**concatenate elements of different types**]{.hl-yellow}?

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

Note that since all elements must be of the same type, what `R` does is [**convert**]{.hl-yellow} everything to text, violating the [**data integrity**]{.hl-red}.


. . .

```{r}
c(3, 4, TRUE, FALSE)
```

It's important to understand that logical values are actually [**internally stored as 0/1**]{.hl-yellow}.


---

## Operations with vectors

With numeric vectors, we can perform the same [**arithmetic operations**]{.hl-yellow} as with numbers ‚Üí a [**number is a vector**]{.hl-purple} (of length one).

. . .

What will happen if we [**add or subtract a value**]{.hl-yellow} to a vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Warning

Unless otherwise specified, in `R`,  vector operations are always [**element by element**]{.hl-orange}.

:::

---

## Adding vectors

Vectors can also interact with each other, so we can define, for example, [**vector sums**]{.hl-yellow} (element by element).


```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

. . .

Since the operation (e.g., a sum) is performed element by element, what will happen if we [**add two vectors of different lengths**]{.hl-yellow}?

. . .


```{r}
z <- c(1, 3, 5, 7)
x + z
```

What it does is [**recycle elements**]{.hl-yellow}: if we have a vector of 4 elements and we add another with 3 elements, it will recycle the elements from the shorter vector.

---

## Comparing vectors

A very common operation is to [**ask questions of the data**]{.hl-yellow} using [**logical conditions**]{.hl-purple}. For example, if we define a vector of temperatures...

[**Which days were below 22 degrees?**]{.hl-yellow}


```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

This will return a [**logical vector**]{.hl-yellow}, depending on whether **each element** meets the given condition (of the **same length** as the vector being queried).

. . .

If we had a [**missing value**]{.hl-yellow} (due to a sensor error that day), the evaluated condition would also be `NA`.


```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Comparing vectors

[**Logical conditions can be combined**]{.hl-yellow} in two ways:

- [**Intersection**]{.hl-yellow}: [**all**]{.hl-purple} concatenated conditions must be met ([**AND conjunction**]{.hl-purple} with `&`) to return `TRUE`.


```{r}
x < 30 & x > 15
```

- [**Union**]{.hl-yellow}: it is enough for [**at least one**]{.hl-purple} condition to be met ([**OR conjunction**]{.hl-purple} with `|`).


```{r}
x < 30 | x > 15
```

. . .

With `any()` and `all()`, we can check if [**all elements**]{.hl-yellow} satisfy the condition.

```{r}
any(x < 30)
all(x < 30)
```

---

## Getting elements

Another common operation is [**accessing or getting elements**]{.hl-yellow}. The simplest way is to use the `[i]`  operator (access the i-th element).

```{r}
ages <- c(20, 30, 33, NA, 61) 
ages[3] # get the age's third person
```

. . .

Since a number is just a vector of length one, this operation can also be applied using a [**vector of indices to select**]{.hl-yellow}.

```{r}
y <- c("hi", "how", "are", "you", "?")
y[c(1:2, 4)] # first, second and fourth element
```

. . .

::: callout-tip

To access the last element without worrying about its position, you can pass the vector's length as the index `x[length(x)]`.

:::

---

## Removing elements

Sometimes, instead of selecting, we may want to [**remove elements**]{.hl-yellow}. This is done with the same operation but using [**negative indexing**]{.hl-purple}: the opetator `[-i]` ¬´un-select¬ª the i-th element 

```{r}
y
y[-2] # everything except the second element
```


. . .

In many cases, we want to [**select or remove elements based on logical conditions**]{.hl-yellow}, depending on the values, so we will pass the condition itself as the index (remember, `x < 2` returns a logical vector).


```{r}
ages <- c(15, 21, 30, 17, 45)
names <- c("javi", "mar√≠a", "sandra", "carla", "luis")
names[ages < 18] # names of people under 18
```

---


## Stats operations

We can also make use of [**statistical operations**]{.hl-yellow}, such as `sum()`, which, given a vector, returns the sum of all its elements.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

[**What happens when a data point is missing?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

By default, if we have a missing data point, the [**operation will also result in a missing value**]{.hl-yellow}. To [**ignore that missing data**]{.hl-purple}, we use the optional argument `na.rm = TRUE`.


```{r}
sum(x, na.rm = TRUE)
```

---

## Stats operations

As we've mentioned, logical values are internally stored as 0 and 1, so we can use them in arithmetic operations.

For example, if we want to [**find out the number of elements that meet a condition**]{.hl-yellow} (e.g., less than 3), those that do will be assigned a 1 (`TRUE`), and those that don't will get a 0 (`FALSE`). Therefore, summing the logical vector will give us the number of elements that meet the condition.


```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Stats operations

Another common operation that can be useful is the [**cumulative sum**]{.hl-yellow} with `cumsum()`, which, given a vector, returns a vector where each element is the sum of the first, the first plus the second, the first plus the second plus the third, and so on.

```{r}
x <- c(1, 5, 2, -1, 8)
cumsum(x)
```

[**What happens when a data point is missing?**]{.hl-yellow}


```{r}
x <- c(1, -2, 3, NA, -1)
cumsum(x)
```

In the case of the cumulative sum, what happens is that [**from that point onward, all subsequent accumulated values will be missing**]{.hl-yellow}.

---

## Stats operations

Another common operation that can be useful is the [**difference (with delay)**]{.hl-yellow} with `diff()` which, given a vector, returns a vector with the second minus the first, the third minus the second, the fourth minus the third...and so on.


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x)
```

. . .

Using the argument `lag = ` we can indicate the [**delay**]{.hl-yellow} of this difference (e.g. `lag = 3` implies that the fourth minus the first, the fifth minus the second, etc.).


```{r}
x <- c(1, 8, 5, 3, 9, 0, -1, 5)
diff(x, lag = 3)
```

---

## Stats operations

Other common operations are [**mean**]{.hl-yellow}, [**median**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

- [**mean**]{.hl-yellow}: centrality measure that consists of adding all the elements and dividing by the number of elements added. The best known but the [**least robust**]{.hl-red}: given a set, if outliers (very large or very small values) are introduced, the mean is very easily perturbed.


```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Stats operations

Other common operations are [**mean**]{.hl-yellow}, [**median**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.


-   [**Median**]{.hl-yellow}: measure of centrality that consists of ordering the elements and keeping the one that occupies the middle.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Quantiles**]{.hl-yellow}: position measurements (they divide the data into equal parts).

```{r}
quantile(x) # by default quantiles/percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

---


## Sorting vectors

Finally, a common action is to know [**sort values**]{.hl-yellow}:

- `sort()`: returns the [**sorted vector**]{.hl-yellow}. By default from smallest to largest but with `decreasing = TRUE` we can change it.


```{r}
ages <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(ages)
sort(ages, decreasing = TRUE)
```

. . .

-   `order()`: returns the [**index vector**]{.hl-yellow} that we would have to use to have the vector ordered

```{r}
order(ages)
ages[order(ages)]
```

---

## üíª It's your turn {#tu-turno-0-2-1}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

üìù Define the vector `x` as the concatenation of the first 5 odd numbers. Calculate the length of the vector

```{r}
#| code-fold: true
#| eval: false
# Two ways
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

length(x)
```

### [**Exercise 2**]{.hl-yellow}

üìù Access the third element of `x`. Access the last element (regardless of length, a code that can always be executed). Delete the first element.

```{r}
#| code-fold: true
#| eval: false
x[3]
x[length(x)]
x[-1]
```

### [**Exercise 3**]{.hl-yellow}

üìù Get the elements of `x` greater than 4. Calculate the vector `1/x` and store it in a variable.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
z <- 1/x
z
```

### [**Exercise 4**]{.hl-yellow}

üìù Create a vector representing the names of 5 people, one of whom is unknown.

```{r}
#| code-fold: true
#| eval: false
names <- c("Javi", "Sandra", NA, "Laura", "Carlos")
names
```

### [**Exercise 5**]{.hl-yellow}

üìù Find from the vector `x` of exercises above the elements greater (strictly) than 1 and less (strictly) than 7. Find a way to find out if all the elements are positive or not.


```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Exercise 6**]{.hl-yellow}

üìù Given the vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, why does its mean return not a number but what is shown in the code below?

```{r}
x <- c(1, -5, 8, NA, 10, -3, 9)
mean(x)
```

### [**Exercise 7**]{.hl-yellow}

üìù Given the vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extract the elements occupying the locations 1, 2, 5, 6. 

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
x[-2]
```

### [**Exercise 8**]{.hl-yellow}

üìù Given the `x` vector of the previous exercise, which ones have a missing data? Hint: the `is.something()` functions check if the element is of type `something` (press tab).


```{r}
#| code-fold: true
#| eval: false
is.na(x)
```


### [**Exercise 9**]{.hl-yellow}

üìù Define the vector `x` as the concatenation of the first 4 even numbers. Calculate the number of elements of `x` strictly less than 5.

```{r}
#| code-fold: true
#| eval: false
x[x < 5] 
sum(x < 5)
```


### [**Exercise 10**]{.hl-yellow}

üìù Calculate the vector `1/x` and obtain the ordered version (from smallest to largest) in the two possible ways

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Exercise 11**]{.hl-yellow}

üìù Calculate min and max of previous `x` vector

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Exercise 12**]{.hl-yellow}

üìù Find of the vector `x` the elements greater (strictly) than 1 and less (strictly) than 6. Find a way to find out if all the elements are negative or not.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

:::


---


## First databases

When analyzing data we usually have [**several variables**]{.hl-yellow} for each individual: we need a "table" to collect them. The most immediate option is [**matrices**]{.hl-yellow}: concatenation of variables of [**same type and equal length**]{.hl-purple}.

Imagine we have heights and weights of 4 people. How to [**create a dataset with the two variables**]{.hl-yellow}?

. . .

The most common option is to use `cbind()`: [**concatenate (bind) vectors in the form of columns (c)**]{.hl-yellow}

```{r}
#| code-line-numbers: "3"
h <- c(150, 160, 170, 180)
w <- c(63, 70, 85, 95)
data_mat <- cbind(h, w)
data_mat 
```

---

## First databases

We can also [**build the matrix by rows**]{.hl-yellow} with the `rbind()` function (concatenate - bind - by rows - r), although it is [**recommended to have each variable in column**]{.hl-green} and individual in row as we will see later.

```{r}
rbind(h, w) # Matrix by rows
```

. . .

- We can [**"view" the matrix**]{.hl-yellow} with `View(matrix)`.

. . .

-   We can [**check dimensions**]{.hl-yellow} with `dim()`, `nrow()` and `ncol()`: matrices are a type of **tabular data** (organized in rows and columns).

```{r}
dim(data_mat)
nrow(data_mat)
ncol(data_mat)
```

---

## First databases

We can also [**"flip" (transposed matrix)**]{.hl-yellow} with `t()`.

```{r}
t(data_mat)
```

. . .

Since we now have two dimensions in our data, to [**access elements with `[]`**]{.hl-yellow} we must provide **two comma-separated indexes**: row and column indexes 

```{r}
data_mat[2, 1] # second row, first column
data_mat[1, 2] # first row, second column
```

---

## First databases

In some cases we will want to get the [**total data for an individual**]{.hl-yellow} (a particular row but all columns) or the values of [**a whole variable**]{.hl-yellow} for all individuals (a particular column but all rows). To do so, we leave [**one of the indexes**]{.hl-yellow} unfilled.

```{r}
data_mat[2, ] # second individual
data_mat[, 1] # first variable
```

. . .

Much of what we have learned with vectors we can do with matrices, so we can for example access multiple rows and/or columns using the [**sequences of integers 1:n**]{.hl-yellow}


```{r}
data_mat[c(1, 3), 1] # first variable for first and third individual
```


---

## First databases

We can also define a [**matrix from a numeric vector**]{.hl-yellow}, rearranging the values in the form of a matrix (knowing that the elements are [**placed by columns**]{.hl-purple}).

```{r}
z <- matrix(1:9, ncol = 3) 
z
```

. . .

We can even [**define an array of constant values**]{.hl-yellow}, e.g. of zeros (to be filled later)


```{r}
matrix(0, nrow = 2, ncol = 3)
```


---

## Matrix operations

With matrices it is the same as with vectors: when we apply an [**arithmetic operation we do it element by element**]{.hl-yellow}

```{r}
z/5
```

. . .

To perform [**operations in a matrix sense**]{.hl-yellow} we must add `%%%`, for example, to multiply matrices it will be `%*%`.

```{r}
z * t(z)
z %*% t(z)
```


---

## Matrix operations

We can also [**perform operations by columns/rows**]{.hl-yellow} without loops with the `apply()` function, and we will indicate as **arguments**

- the matrix
- the sense of the operation (`MARGIN = 1` for rows, `MARGIN = 2` for columns)
- the function to apply
- extra arguments needed by the function

. . .

For example, to apply an average to each variable, it will be `mean` applied with `MARGIN = 2` (same function for each column).

```{r}
# Mean for each column (MARGIN = 2)
apply(data_mat, MARGIN = 2, FUN = "mean")
```



---

## üíª It's your turn {#tu-turno-0-2-2}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset

### [**Exercise 1**]{.hl-yellow}

üìù Modify the code below to define an `x` matrix of ones, with 3 rows and 7 columns.

```{r}
#| eval: false
x <- matrix(0, nrow = 2, ncol = 3)
x
```

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1, nrow = 3, ncol = 7)
x
```

### [**Exercise 2**]{.hl-yellow}

üìù To the above matrix, add 1 to each number in the matrix and divide the result by 5. Then calculate its transpose

```{r}
#| code-fold: true
#| eval: false
new_matrix <- (x + 1)/5
t(new_matrix)
```

### [**Exercise 3**]{.hl-yellow}

üìù Why does the code below return such a warning message?

```{r}
#| warning: TRUE
matrix(1:15, nrow = 4)
```



### [**Exercise 4**]{.hl-yellow}

üìù Define the matrix `x <- matrix(1:12, nrow = 4)`. Then get the data of the first individual, the data of the third variable, and the element `(4, 1)`.

```{r}
#| code-fold: true
#| eval: false
x <- matrix(1:12, nrow = 4)
x[1, ] # first row
x[, 3] # third column
x[4, 1] # (4, 1) element
```

### [**Exercise 5**]{.hl-yellow}

üìù Define a matrix of 2 variables and 3 individuals such that each variable captures the height and age of 3 persons, so that the age of the second person is unknown (absent). Then calculate the mean of each variable (we should get a number!).

```{r}
#| code-fold: true
#| eval: false
data <- cbind("age" = c(20, NA, 25), "h" = c(160, 165, 170))
apply(data, MARGIN = 2, FUN = "mean", na.rm = TRUE) # mean by columns

```

### [**Exercise 6**]{.hl-yellow}

üìù Why does the lower code return an error? What is wrong?

```{r}
#| error: true
mat <- cbind("age" = c(15, 20, 25), "names" = c("javi", "sandra", "carlos"))
mat
mat + 1
```

:::

---

## Second attempt: data.frame

Arrays have the same problem as vectors: if we put together data of different types, it [**data integrity is compromised**]{.hl-red} as it converts them (see the code below: the ages and the `TRUE/FALSE` are converted to text).


```{r}
#| code-line-numbers: "4-5"
ages <- c(14, 24, NA)
single <- c(TRUE, NA, FALSE)
names <- c("javi", "laura", "luc√≠a")
mat <- cbind(ages, single, names)
mat
```

. . .

In fact, since they are not numbers, we can no longer perform arithmetic operations.

```{r}
#| error: true
mat + 1
```

---

## Second attempt: data.frame

In order to work with [**variables of different type**]{.hl-yellow} we have in `R` what is known as [**data.frame**]{.hl-yellow}: concatenation of variables of equal length but which can be of [**different type**]{.hl-purple}.

```{r}
table <- data.frame(ages, single, names)
class(table)
table
```

---

## Second attempt: data.frame

Since a `data.frame` is already an attempt at a `database` the variables are not mere mathematical vectors: [**they have a meaning**]{.hl-yellow} and we can (we must) [**give them names**]{.hl-purple} that describe their meaning.

```{r}
library(lubridate)
table <-
  data.frame("ages" = ages, "single" = single, "names" = names,
             "birth_date" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
table
```

---

## Second attempt: data.frame

[**We have our first data set!**]{.hl-yellow} (strictly speaking we can't talk about a database but for the moment it looks like one). You can visualize it by typing its name in console or with `View(table)`.

![](img/view_tabla.jpg)

---

## Get variables

If we want to access its elements, being again **tabulated data**, we can access as in the matrices ([**not recommended**]{.hl-red}): again [**we have two indexes**]{.hl-yellow} (rows and columns, leaving free the one we don't use)


```{r}
table[2, ]  # second row (all variables)
table[, 3]  # third column (all individuals)
table[2, 1] # first variable of the second individual
```

. . .

::: columns
::: {.column width="25%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="75%"}

But it also has the advantages of a [**database**]{.hl-yellow} : we can [**access the variables by name**]{.hl-purple} ([**recommended**]{.hl-green} since the variables can change position and now they have a meaning), putting the name of the table followed by the symbol `$` (with the **tab**, a menu of columns to choose from will appear).

:::
:::

---

## Ask functions

- `names()`: shows us the variable names

```{r}
names(table)
```

. . .

- `dim()`: shows dimensions (also `nrow()` and `ncol()`)

```{r}
dim(table)
```

. . .

-  Variables can be accessed by name

```{r}
table[c(1, 3), "names"]
table$names[c(1, 3)]
```

---

## Add a variable

If we have one already created and we want to [**add a column**]{.hl-yellow} it is as simple as using the `data.frame()` function we have already seen to concatenate the column. Let's add for example a new variable, the number of siblings of each individual.

```{r}
# add a new column
siblings <- c(0, 2, 3)
table <- data.frame(table, "n_sib" = siblings)
table
```

---

## üíª It's your turn {#tu-turno-0-2-3}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset

### [**Exercise 1**]{.hl-yellow}

üìù Load from the `{datasets}` package the `airquality` dataset (New York air quality variables from May through September 1973). Is the airquality dataset of type tibble? If not, convert it to tibble (look in the package documentation at <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Exercise 2**]{.hl-yellow}

üìù Once converted to `tibble` get the name of the variables and the dimensions of the data set. How many variables are there? How many days have been measured?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```


### [**Exercise 3**]{.hl-yellow}

üìù Filters only the data of the fifth observation

```{r}
#| code-fold: true
#| eval: false
airquality_tb[5, ]
```

### [**Exercise 4**]{.hl-yellow}

üìù Filter only the data for the month of August. How to tell it that we want only the rows that meet a specific condition?

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, ]

# other way
var_month <- airquality_tb$Month
airquality_tb[var_month == 8, ]
```

### [**Exercise 5**]{.hl-yellow}

üìù Select those data that are not from July or August.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month != 7 & airquality_tb$Month != 8, ]
airquality_tb[!(airquality_tb$Month %in% c(7, 8)), ]
```

### [**Exercise 6**]{.hl-yellow}

üìù Modify the following code to keep only the ozone and temperature variables (no matter what position they are).

```{r}
#| eval: false
airquality_tb[, 3]
```

### [**Exercise 7**]{.hl-yellow}

üìù Select the temperature and wind data for August. 

```{r}
#| code-fold: true
#| eval: false
airquality_tb[airquality_tb$Month == 8, c("Temp", "Wind")]
```

### [**Exercise 8**]{.hl-yellow}

üìù Translate the name of the variables into your native language.


```{r}
#| code-fold: true
#| eval: false
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```

:::

---

## üê£ Case study I {#caso-practico-0-2-1}

The **National Health and Nutrition Examination Survey (NHANES)** is a large, nationally representative program conducted in the **United States to assess the health and nutritional status** of adults and children. NHANES combines interviews, physical examinations, and laboratory measurements. NHANES is widely used in epidemiology, public health research, and policy analysis. 

```{r}
#| eval: false
# install.packages("NHANES")
library(NHANES)
NHANES
```

```{r}
#| echo: false
# install.packages("NHANES")
head(NHANES::NHANES[, 1:15])
```

Try to answer the questions posed in the **workbook `intro-R`**


---

## üê£ Case study II {#caso-practico-0-2-2}

In the `{datasets}` package (already installed by default) we have several datasets and one of them is `airquality`. Below I have extracted 3 variables from that dataset (note that it is done with `data$variable`, that dollar will be important in the future).The data captures [**daily measurements (n = 153 observations) of air quality**]{.hl-yellow} in New York, from May to September 1973. Six **6 variables** were measured: ozone levels, solar radiation, wind, temperature, month and day.

```{r}
library(datasets)
temperature <- airquality$Temp
month <- airquality$Month
day <- airquality$Day
```

Try to answer the questions posed in the **workbook `intro-R`**


---

## üê£ Case study III {#caso-practico-0-2-3}

We will consider the `surveys.RData` file in which we have all poll surveys for Spain from 1982 to 2019.

```{r}
#| eval: false
load(file = "./data/surveys.RData")
survey_data
```


Try to answer the questions posed in the **workbook `intro-R`**






# L3 : [welcome to tidyverse]{.flow} {#clase-0-3}

[**Welcome to tidyverse. First actions against databases**]{style="color:#444442;"}

* [üíª Solved exercises: vectors](#tu-turno-0-2-1) 

* [üíª Solved exercises: data.frame and tibble](#tu-turno-0-2-3) 

* [üê£ Workbook/case study I-II](#caso-practico-0-2-1)

* [üìÜ Planning](#planificacion)

---


## Last attempt: tibble

Tables in `data.frame` format have some [**limitations**]{.hl-red}. The main one is that [**does not allow recursion**]{.hl-red}: imagine that we define a database with heights and weights, and we want a third variable with the BMI.


```{r}
#| error: true
data.frame("height" = c(1.7, 1.8, 1.6), "weight" = c(80, 75, 70),
           "BMI" = weight / (height^2))
```

. . .


Hereafter we will use the `tibble` ([**enhanced data.frame**]{.hl-yellow}) format from the `{tibble}` package.

```{r}
library(tibble)
data_tb <- 
  tibble("height" = c(1.7, 1.8, 1.6), "weight" = c(80, 75, 70), "BMI" = weight / (height^2))
class(data_tb)
data_tb
```

---

## Last attempt: tibble

```{r}
data_tb <- 
  tibble("height" = c(1.7, 1.8, 1.6), "weight" = c(80, 75, 70), "BMI" = weight / (height^2))
class(data_tb)
data_tb
```

Las tablas en formato `tibble` nos permitir√° una [**gesti√≥n m√°s √°gil, eficiente y coherente**]{.hl-yellow} de los data, con 4 ventajas principales:

. . .

- [**Metainformation**]{.hl-yellow}: if you look at the header, it automatically tells us the number of rows and columns, and the type of each variable

. . .

- [**Recursivity**]{.hl-yellow}: allows you to define the variables sequentially (as we have seen)



---

## Last attempt: tibble {#data-pasta}

- [**Consistency**]{.hl-yellow}: if you access a column that does not exist, it warns

```{r}
#| warning: true
data_tb$invent
```

. . .

- [**By rows**]{.hl-yellow}: create by rows (copy and paste from a table) with `tribble()`.

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
The `{datapasta}` package allows us to [**copy and paste**]{.hl-green} tables from web pages and simple documents as a tribble. See more in <https://milesmcbain.github.io/datapasta/articles/how-to-datapasta.html#pasting-a-table-as-a-formatted-tibble-definition-with-tribble_paste>
:::


---


## In summary...

- Each [**cell can be of a different type**]{.hl-yellow}: numbers, text, dates, logical values, etc. A [**vector is a concatenation of cells**]{.hl-yellow} (the future columns of our tables) --> In `R` by default operations are done [**element to element**]{.hl-yellow}.

. . .

- A [**matrix**]{.hl-yellow} allows us to concatenate [**variables of the SAME type and SAME length**]{.hl-yellow} --> tabular data.

. . .

- A [**data.frame**]{.hl-yellow} allows us to concatenate [**variables of DIFFERENT type and SAME length**]{.hl-yellow} --> we will use [**tibble**]{.hl-yellow} as an enhanced database option.

---

## Previously, in Breaking Bad...


- Almost all ¬´data objects¬ª in `R` are vectors: a concatenation of values of the SAME TYPE

```{r}
vec_num <- c(1, 3, NA, 6)
vec_string <- c("a", "b", "a", "d", "a", "e") # string = character
vec_logical <- vec_string == "a"

# dates ALWAYS as a character to conver to date (by default "yyyy-mm-dd" format)
vec_dates <- c(as_date("1989-09-10"), as_date("1994-04-13"), as_date("1960-05-10"))
```

. . .

- What happens if we try to combine different types of data?

```{r}
c(1, "a", 2)
c("a", TRUE, FALSE, 1)
c(as_date("1989-09-10"), "b", "a")
```

---

## Previously, in Breaking Bad...

- What happens if we try to use variables that they don't exist?

```{r}
#| error: true
x <- -1
y <- 0

X + y
```

. . .

- Why does the lower code not produce an error?

```{r}
#| error: true
"TRUE" + 1
```

---

## Previously, in Breaking Bad...

- How to access to elements in a vector? Using `()` or `[]`?

. . .

- Which is the properly output?

```{r}
#| eval: false
x <- seq(-1, 10, by = 2)
x[c(3:4, 6)]
```

---

## Previously, in Breaking Bad...

- How to combine logical operators to filter elements in a vector by conditions?


```{r}
#| eval: false
x <- c(-1, 2, 3, 7, 0, 4)
y <- c(-5, -2, 4, -5, 4, 2)
z <- c(1, 2, 3, 4, 5, 6)
y[x > 2 | z < 3] # result?
y[x > 2 & z < 3] # result?
```


---

## Previously, in Breaking Bad...


- What happens if we try to do arithmetic operations to a vector? Is the output a single number? A vector of length...?

```{r}
#| eval: false
x <- c(-1, 0, NA, 2, 10, -7)
x * 5 # result?
x + 1
```

. . .

- What happens if we try to sum vectors? Why does fail the second code?

```{r}
#| eval: false
x <- c(-1, 0, NA, 2, 10, -7)
y <- c(0, 3, 5, NA, 7, 3)
z <- c(0, 1, -4, 2, 6)
  
# ok (output?)
x + y
x + z
```

## Previously, in Breaking Bad...


- What happens if you ask to a vector if its elements verify a condition?

```{r}
#| eval: false
x <- c(0, 1, -4, 2, -6)
x <= 0
```

. . .

Reminder that...

- Ask which elements verify conditions: `x <= 0`
- Access to elements in the same position that that ones that verify conditions: `x[x <= 0]` or `y[x <= 0]` 
- How many elements verify conditions?: `sum(x <= 0)`
- Which proportion verify conditions?: `mean(x <= 0)`
- All of them verify conditions? Any?: `all(x <= 0)` or any(x <= 0)`

---

## Previously, in Breaking Bad...


- How to order a vector?

```{r}
x <- c(0, 1, -4, 2, -6)
sort(x) # ascendending
sort(x, decreasing = TRUE) # descending
```

. . .

Reminder that `something()` means a function and arguments are inside of `()`: there are optional arguments that modify the default mode of functions.

. . .

- How to do statistical operations?

```{r}
mean(x)
median(x)
var(x)
quantile(x, probs = c(0.15, 0.67, 0.9))
```


---

## Previously, in Breaking Bad...

- Why matrices are bad idea?

. . .

```{r}
x <- c(1, 2, 3)
y <- c("a", "b", "c")
cbind(x, y)
```

. . .

Our [**final database format**]{.hl-yellow} will be the `tibble` type object, an enhanced `data.frame`.

```{r}
library(tibble)
tibble("height" = c(1.7, 1.8, 1.6), "weight" = c(80, 75, 70), "BMI" = weight / (height^2))
```

- [**Metainformation**]{.hl-yellow}: in the header it automatically tells us the number of rows and columns, and the type of each variable.

- [**Recursivity**]{.hl-yellow}: allows to define the variables sequentially (as we have seen).

- [**Consistency**]{.hl-yellow}: if you access a column that does not exist it warns you with a warning.


---

## Previously, in Breaking Bad...

To define a `tibble()` ourselves we have 3 options:

1. [**Concatenating vectors**]{.hl-yellow} that we already have defined, making use of the `tibble()` function of the `{tibble}` package (already included in `{tidyverse}`)

```{r}
height <- c(1.7, 1.8, 1.6)
weight <- c(80, 75, 70)
BMI <- weight / (height^2)
tibble("height" = height, "weight" = weight, "BMI" = BMI)
```

---

## Previously, in Breaking Bad...

2. [**Directly in a tibble**]{.hl-yellow} manually providing values and variable names

```{r}
tibble("height" = c(1.7, 1.8, 1.6),
       "weight" = c(80, 75, 70),
       "BMI" = weight / (height^2))
```

. . .

or ... 3. import from an Excel/csv (we will see, be patient <3).

---

## R base vs Tidyverse

So far, everything we have done in `R` has been done in the programming paradigm known as [**R base**]{.hl-yellow}. When `R` was born as a language, many of those who programmed in it imitated forms and methodologies inherited from other languages, based on the use of

- Loops [**for**]{.hl-yellow} and [**while**]{.hl-yellow}

- Dollar `$` to access to the variables 

- Structures [**if-else**]{.hl-yellow}

And although knowing these structures can be interesting in some cases, in [**most cases they are obsolete and we will be able to avoid them**]{.hl-red} (especially loops) since `R` is specially [**designed to work in a functional way**]{.hl-yellow} (instead of element-by-element).

---

## What is tidyverse?

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

In this context of functional programming, a decade ago `{tidyverse}` was born, a [**‚Äúuniverse‚Äù of packages**]{.hl-yellow} to guarantee an efficient, coherent and lexicographically simple to understand workflow, based on the idea that [**our data is clean and tidy**]{.hl-purple}.

```{r}
library(tidyverse)
```


---

## What is tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)

- `{lubridate}`: date management
- `{rvest}`: web scraping
- `{tidymodels}`: modeling/prediction

:::

::: {.column width="55%"}

- `{tibble}`: optimizing data.frame
- `{tidyr}`: data cleaning
- `{readr}`: load rectangular data (.csv), `{readxl}`: import .xls and .xlsx files
- `{dplyr}`: grammar for debugging
- `{stringr}`: text handling
- `{purrr}`: list handling
- `{forcats}`: qualitative handling
- `{ggplot2}`: data visualization

:::
:::



---

## What is tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)

- `{lubridate}`: date management
- `{rvest}`: web scraping
- `{tidymodels}`: modeling/prediction

:::

::: {.column width="55%"}

- `{tibble}`: [**optimizing data.frame**]{.hl-yellow}
- `{tidyr}`: [**data cleaning**]{.hl-yellow}
- `{readr}`: load rectangular data (.csv), `{readxl}`: import .xls and .xlsx files
- `{dplyr}`: grammar for debugging
- `{stringr}`: text handling
- `{purrr}`: list handling
- `{forcats}`: qualitative handling
- `{ggplot2}`: data visualization

:::
:::


---

## Basic idea: tidy data

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

::: {style="font-size:120px; text-align: center; color:#F8DF58;"}
<b>TIDY</b><b>[VERSE</b>]{style="color:#CAB0EE;"}
:::

The [**universe**]{.hl-purple} of `{tidyverse}` packages is based on the idea introduced by **Hadley Wickham** (the God we pray to) of [**standardizing**]{.hl-yellow} the format of data to

::: incremental
- [**systematize**]{.hl-green} debugging
- make it easier [**simpler**]{.hl-green} to manipulate
- [**legible**]{.hl-green} code.
:::

---

## Rules

The first thing will therefore be to understand what the [**tidydata sets**]{.hl-yellow} are, since the whole `{tidyverse}` is based on the data being standardized.

::: columns
::: {.column width="50%"}
::: {.fragment .fade-in}
1.  Each [**variable**]{.hl-yellow} in a [**single column**]{.hl-purple}
:::

::: {.fragment .fade-in}
2.  Each [**individual**]{.hl-yellow} in a [**different row**]{.hl-purple}
:::

::: {.fragment .fade-in}
3.  Each [**cell**]{.hl-yellow} with a [**single value**]{.hl-purple}
:::

::: {.fragment .fade-in}
4.  Each [**dataset**]{.hl-yellow} in a [**tibble**]{.hl-purple}
:::

::: {.fragment .fade-in}
5.  If we want to join [**multiple datasets**]{.hl-yellow} we must have a [**common (key) column**]{.hl-purple}.
:::
:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
:::

---

## Pipe

In `{tidyverse}` the [**operator pipe (pipe)**]{.hl-yellow} defined as `|>` ([**ctrl+shift+M**]{.hl-purple}) will be key: it will be a [**pipe that traverses the data**]{.hl-yellow} and transforms it.
. . .

::: columns
::: {.column width="50%"}

In R base, if we want to apply three functions `first()`, `second()` and `third()` in order, it would be

```{r}
#| eval: false
third(second(first(data)))
```
:::

::: {.column width="50%"}

In `{tidyverse}` we can [**read from left to right**]{.hl-yellow} and separate data from the actions

```{r}
#| eval: false
data |> first() |> second() |> third()
```
:::
:::


. . .

::: callout-caution
## Important

Since version 4.1.0 of `R` we have `|>`, a **native** pipe available [**outside tidyverse**]{.hl-purple}, replacing the [**old pipe**]{.hl-red} `%>%` which depended on the `{magrittr}` package (quite problematic).

:::

---

## Pipe

The main advantage is that the [**code is very readable (almost literal)**]{.hl-yellow} and you can do large operations on the data with very little code.

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  tidy(...) |>
  filter(...) |>
  select(...) |>
  arrange(...) |>
  modify(...) |>
  rename(...) |>
  group(...) |>
  count(...) |>
  summarise(...) |>
  plot(...)
```
:::

::: {.column width="50%"}
<center><img src="img/logo_pipe.png" width="360px"/></center>
:::
:::

---

## R base vs Tidyverse

Before in R base

```{r}
#| eval: false
output1 <- something_to_do_1(dataset$variable1)
output2 <- something_to_do_2(output1$variable2)
output3 <- something_to_do_3(output1$variable3)
```

. . .

Now in tidyverse

```{r}
#| eval: false
dataset |>
  something_to_do_1(variable1) |>
  something_to_do_2(variable2) |>
  something_to_do_3(variable3)
```

---

## R base vs Tidyverse

Before in R base: get the Ozone and Temperature variables from July

. . .

```{r}
airquality_tb <- tibble(airquality)
airquality_tb[airquality_tb$Month == 7, c("Ozone", "Temp")]
```

. . .


Now in tidyverse (thanks to conect with pipe we don't need `" "` neither `$`)

```{r}
airquality_tb |> 
  filter(Month == 7) |> 
  select(Ozone, Temp)
```

---


## Preprocessing: dplyr

Within `{tidyverse}` we will use the `{dplyr}` package for the [**preprocessing process**]{.hl-yellow} of the data.

::: columns
::: {.column width="60%"}
![](img/dplyr.png){width=450}
:::

::: {.column width="40%"}
```{r}
#| eval: false
data |>
  tidy(...) |>
  filter(...) |>
  select(...) |>
  arrange(...) |>
  modify(...) |> # mutate in the code
  rename(...) |>
  group(...) |>
  count(...) |>
  summarise(...) |>
  plot(...) # actually ggplot
```
:::
:::

The idea is that the [**code is as readable as possible**]{.hl-yellow}, as if it were a **list of instructions** that when read tells us in a very obvious way what it is doing.


---

## Assumption: tidydata

::: columns
::: {.column width="50%"}

All the preprocessing process we are going to perform is on the [**assumption that our data is in tidydata**]{.hl-yellow}

:::

::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
::::

Remember that in `{tidyverse}` the [**pipe operator**]{.hl-yellow} defined as `|>` ([**ctrl+shift+M**]{.hl-purple}) will be key: it will be a [**pipe that traverses the data**]{.hl-yellow} and transforms it.


. . .

Let us practice with the `starwars` dataset from the `{dplyr}` package.

```{r}
#| eval: false
library(tidyverse)
starwars
```

---


## Sampling

:::: columns
::: {.column width="60%"}

One of the most common operations is what is known in statistics as [**sampling**]{.hl-yellow}: a [**selection or filtering of records (rows)**]{.hl-yellow} (a subsample).


:::

::: {.column width="40%"}

![](img/muestreo.jpeg){width=500}
:::
::::

. . .


* [**Non-random (by quota)**]{.hl-purple}: based on logical conditions on the records (`filter()`).

. . .

* [**Non-random (intentional/discretionary)**]{.hl-purple}: based on a position (`slice()`).

. . .

* [**Simple random**]{.hl-purple} (`slice_sample()`).

. . .

* [**Stratified**]{.hl-purple} (`group_by()` + `slice_sample()`).


---

## Filter rows: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  filtro(condition)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condition)
```
:::
:::

The simplest action by rows is when [**filter records**]{.hl-yellow} based on some logical condition: with `filter()` only individuals meeting certain conditions will be selected (non-random sampling by conditions).


::: incremental
-   `==`, `!=`: [**equal**]{.hl-purple} or [**different**]{.hl-yellow} to (`|> filter(variable == "a")`)
-   `>`, `<`: [**greater**]{.hl-purple} or [**less**]{.hl-yellow} than (`|> filter(variable < 3)`)
-   `>=`, `<=`: [**greater or equal**]{.hl-yellow} or [**less or equal**]{.hl-purple} than (`|> filter(variable >= 5)`)
-   `%in%`: values [**belong**]{.hl-yellow} to a set of discrete options (`|> filter(variable %in% c("blue", "green"))`)
-   `between(variable, val1, val2)`: if continuous values are [**inside of a range**]{.hl-yellow} (`|> filter(between(variable, 160, 180))`)
:::

---

## Filter rows: filter()

These [**logical conditions**]{.hl-yellow} can be [**combined**]{.hl-yellow} in different ways (and, or, or mutually exclusive).


![](img/tablas_verdad.png)

. . .


::: callout-tip
## Important

Remember that inside `filter()` there must always be something that returns a [**vector of logical values**]{.hl-green}.

:::

---

## Filter rows: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  filtro(condition)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condition)
```
:::
:::

How would you go about... [**filter**]{.hl-yellow} the characters with [**brown eyes**]{.hl-purple}?

. . .

[**What type of variable is it?**]{.hl-yellow} --> The `eye_color` variable is qualitative so it is represented by texts.

. . .

```{r}
#| echo: false
#| include: false
library(tidyverse)
```

```{r}
starwars |>
  filter(eye_color == "brown")
```

---

## Filter rows: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  filtro(condition)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condition)
```
:::
:::

How would you go about... [**filter**]{.hl-yellow} the characters that [**do not have brown eyes**]{.hl-purple}?

. . .


```{r}
starwars |>
  filter(eye_color != "brown")
```

---

## Filter rows: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  filtro(condition)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condition)
```
:::
:::

How would you go about ... [**filter**]{.hl-yellow} characters that [**have brown or blue eyes**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color %in% c("blue", "brown"))
```

---

## Filter rows: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  filtro(condition)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condition)
```
:::
:::

Note that `%in%` is equivalent to concatenating several `==` with a conjunction or (`|`)

```{r}
starwars |>
  filter(eye_color == "blue" | eye_color == "brown")
```

---

## Filter rows: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  filtro(condition)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condition)
```
:::
:::

How would you go about ... [**filter**]{.hl-yellow} the characters that [**are between 120 and 160 cm**]{.hl-purple}?

. . .

[**What type of variable is it?**]{.hl-yellow} --> The variable `height` is a continuous quantitative variable so we must filter by ranges of values (intervals) --> we will use `between()`.

. . .

```{r}
starwars |>
  filter(between(height, 120, 160))
```


---

## Filter rows: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  filtro(condition)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condition)
```
:::
:::

How would you... [**filter**]{.hl-yellow} characters that [**have eyes and are not human**]{.hl-purple}?

. . .

```{r}
starwars |>
  filter(eye_color == "brown" & species != "Human")
```

---

## Filter rows: filter()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  filtro(condition)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condition)
```
:::
:::

How would you... [**filter**]{.hl-yellow} characters that [**have eyes and are not human, or are over 60 years old**]{.hl-purple}? Think it through: the [**parentheses are important**]{.hl-yellow}: $(a+b)*c$ is not the same as $a+(b*c)$.

. . .

```{r}
starwars |>
  filter((eye_color == "brown" & species != "Human") | birth_year > 60)
```

---

## Drop missings: drop_na()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  drop_missings(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(var1, var2, ...)
```
:::
:::

There is a special **filter** for one of the most common operations in debugging: [**remove absent**]{.hl-yellow}. For this we can use inside a filter `is.na()`, which returns `TRUE/FALSE` depending on whether it is absent, or ...

. . .

Use `drop_na()`: if we do not specify a variable, it removes records with missing in any variable. Later on we will see how to [**impute those missing**]{.hl-yellow} 

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(mass, height)
```

```{r}
#| echo: false
starwars |>
  drop_na(mass, height, sex) |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na()
```

```{r}
#| echo: false
starwars |>
  drop_na() |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::
:::

---

## üíª It's your turn {#tu-turno-3-1}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset

### [**Exercise 1**]{.hl-yellow}

üìù Select from the starwars set only those characters that are androids or whose `species` value is unknown.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Droid" | is.na(species))
```

### [**Exercise 2**]{.hl-yellow}

üìù Select from the starwars set only the characters whose weight is between 65 and 90 kg.

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(between(mass, 65, 90))
```

### [**Exercise 3**]{.hl-yellow}

üìù After clearing absent in all variables, select from the starwars set only the characters that are human and come from Tatooine.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na() |> 
  filter(species == "Human" & homeworld == "Tatooine")
```

### [**Exercise 4**]{.hl-yellow}

üìù Select from the original starwars set non-human characters, `male` in sex and measuring between 120 and 170 cm, or characters with brown or red eyes.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter((species != "Human" & sex == "male" &
            between(height, 120, 170)) |
           eye_color %in% c("brown", "red"))
```

### [**Exercise 5**]{.hl-yellow}

üìù Look for information in the `str_detect()` function help of the `{stringr}` package (loaded in `{tidyverse}`). Tip: test the functions you are going to use with some test vector beforehand so that you can check how they work. After you know what it does, filter out only those characters with the last name `Skywalker`.

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(str_detect(name, "Skywalker"))
```
:::

---

## Slices of data: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |> slice(positions)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice(positions)
```
:::
:::

Sometimes we may be interested in performing a [**non-random discretionary sampling**]{.hl-yellow}, or in other words, [**filter by position**]{.hl-yellow}: with `slice(positions)` we can select specific rows by passing as argument a [**index vector**]{.hl-yellow}.

. . .

::: columns
::: {.column width="50%"}
```{r}
#| eval: false

# fila 1
starwars |>
  slice(1)
```

```{r}
#| echo: false
starwars |> slice(1) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false

# from the 7th to the 9th row
starwars |>
  slice(7:9)
```

```{r}
#| echo: false
starwars |> slice(7:9) |> select(name:hair_color)
```
:::
:::

. . .

```{r}
#| eval: false

# 2, 7, 10 and 31th rows
starwars |>
  slice(c(2, 7, 10, 31))
```

```{r}
#| echo: false
starwars |>
  slice(c(2, 7, 10, 31)) |> select(name:sex)
```

---

## Slices of data: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  slice(positions)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(positions)
```
:::
:::

We have default options:

* with `slice_head(n = ...)` and `slice_tail(n = ...)` we can get the [**header and tail**]{.hl-yellow} of the table

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_head(n = 2)
```

```{r}
#| echo: false
starwars |> slice_head(n = 2) |> select(name:hair_color)
```
:::

::: {.column width="\"50%"}
```{r}
#| eval: false
starwars |> slice_tail(n = 2)
```

```{r}
#| echo: false
starwars |> slice_tail(n = 2) |> select(name:hair_color)
```
:::
:::

---

## Slices of data: slice()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  slice(positions)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice(positions)
```
:::
:::

We have default options:

* with `slice_max()` and `slice_min()` we get the [**rows with smallest/largest value of a variable**]{.hl-yellow} (if tie, all unless `with_ties = FALSE`) which we indicate in `order_by = ...`.

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_min(mass, n = 2)
```

```{r}
#| echo: false
starwars |> slice_min(n = 2, order_by = mass) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_max(height, n = 2)
```

```{r}
#| echo: false
starwars |> slice_max(n = 2, order_by = height) |> select(name:hair_color)
```
:::
:::

---

## Random sampling

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  slice_aleatorias(positions)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(positions)
```
:::
:::

The so-called [**simple random sampling**]{.hl-yellow} is based on [**selecting individuals randomly**]{.hl-yellow}, so that each one has certain [**probabilities**]{.hl-yellow} of being selected. With `slice_sample(n = ...)` we can randomly extract n (a priori equiprobable) records.

```{r}
starwars |> slice_sample(n = 2)
```

. . .

::: callout-important
## Important

[**"Random" does not imply equiprobable**]{.hl-yellow}: a normal die is just as random as a trick die. There are no things "more random" than others, they simply have different underlying probability laws.


:::

---

## Random sampling

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  slice_random(positions)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(positions)
```
:::
:::

We can also indicate the [**proportion of data to sample**]{.hl-yellow} (instead of the number) and if we want it to be [**with replacement (that can be repeated)**]{.hl-yellow}.

```{r}
# 5% of random rows with replacement
starwars |> 
  slice_sample(prop = 0.05, replace = TRUE)

```


---


## Random sampling

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |>
  slice_random(positions)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  slice_sample(positions)
```
:::
:::

As we said, "random" is not the same as "equiprobable", so we can pass a [**probability vector**]{.hl-yellow}. For example, let's force that it is very improbable to draw a row other than the first two rows

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

. . .

```{r}
starwars |>
  slice_sample(n = 2, weight_by = c(0.495, 0.495, rep(0.01/85, 85)))
```

---

## sample()

The `slice_sample()` function is simply a `{tidyverse}` integration of the basic `R` function known as `sample()` that allows us to [**sample elements**]{.hl-yellow}


. . .

For example, let's [**sample 10 rolls of a die**]{.hl-yellow}, telling it

- [**support**]{.hl-purple} of our random variable (allowed values in `x`)
- [**sample size**]{.hl-purple} (`size`)
- [**replacement**]{.hl-purple} (if `TRUE` then they can come out repeated, as in the case of the die).

```{r}
sample(x = 1:6, size = 10, replace = TRUE)
```

---

## sample()

The previous option generates events of a random variable [**equiprobable**]{.hl-yellow} but as before, we can assign a vector of probabilities or [**mass function**]{.hl-yellow} to it with the argument `prob = ...`.


```{r}
sample(x = 1:6, size = 50, replace = TRUE,
       prob = c(0.5, 0.2, 0.1, 0.1, 0.05, 0.05))
```

---


## sample()

**How would you make the following statement?**

&nbsp;

Suppose that seasonal flu episodes have been studied in a city. Let $X_m$ and $X_p$ be random variables such that $X_m=1$ if the mother has flu, $X_m=0$ if the mother does not have flu, $X_p=1$ if the father has flu and $X_p=0$ if the father does not have flu. The theoretical model associated with this type of epidemics indicates that the joint distribution is given by $P(X_m = 1, X_p=1)=0.02$, $P(X_m = 1, X_p=0)=0.08$, $P(X_m = 1, X_p=0)=0. 1$ and $P(X_m = 0, X_p=0)=0.8$

**Generate a sample** of size $n = 1000$ (support `"10"`, `"01"`, `"00"` and `"11"`) by making use of `runif()` and by making use of `sample()`.


---


## Sort by rows: arrange()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |> sort(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(var1, var2, ...)
```
:::
:::

We can also [**order by rows**]{.hl-yellow} according to some variable with `arrange()`.

```{r}
#| eval: false
starwars |> arrange(mass)
```

```{r}
#| echo: false
starwars |> arrange(mass) |> select(name:eye_color) |> slice(1:5) 
```

. . .

By [**from lowest to highest**]{.hl-yellow} but we can [**reverse the order**]{.hl-purple} with `desc()`.


::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(desc(height))
```

```{r}
#| echo: false
starwars |> arrange(desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(mass, desc(height))
```

```{r}
#| echo: false
starwars |> arrange(mass, desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::
:::

---

## Remove duplicates: distinct()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
data |> no_duplicates(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> distinct(var1, var2, ...)
```
:::
:::

Many times we will need to make sure that there are no duplicates in some variable (DNI) and we can [**delete duplicate rows**]{.hl-yellow} with `distinct()`.

```{r}
starwars |> distinct(sex)
```

. . .

To keep all the columns of the table we will use `.keep_all = TRUE`.

```{r}
#| eval: false
starwars |> distinct(sex, .keep_all = TRUE)
```

```{r}
#| echo: false
starwars |> distinct(sex, .keep_all = TRUE) |> slice(1:3)
```

---

## Including rows: bind_rows()

::: columns
::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> include_rows(tibble2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> bind_rows(tibble2)
```
:::
:::

Finally, we can [**bind new rows**]{.hl-yellow} with `bind_rows()` with [**new observations in table**]{.hl-red} (if columns do not match fill with absent)

```{r}
data <-
  tibble("name" = c("javi", "laura"), "age" = c(33, 50))
data
```

. . .

```{r}
data |> bind_rows(tibble("name" = c("carlos", NA), "cp" = c(28045, 28019)))
```

---


## üíª It's your turn {#tu-turno-3-2}

[**Try to perform the following exercises without looking at the solutions**]{style="color:#444442;"}

::: panel-tabset
### [**Exercise 1**]{.hl-yellow}

üìù Select only the characters that are human and brown-eyed, then sort them in descending height and ascending weight.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(eye_color == "brown" & species == "Human") |> 
  arrange(height, desc(mass))
```

### [**Exercise 2**]{.hl-yellow}

üìù Randomly extracts 3 records.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(n = 3)
```

### [**Exercise 3**]{.hl-yellow}

üìù Extracts 10% of the records randomly.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(prop = 0.1)
```

### [**Exercise 4**]{.hl-yellow}

üìùR andomly draws 10 characters but in such a way that the probability of each character being drawn is proportional to its weight (heavier, more likely).

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass) |> 
  slice_sample(n = 10, weight_by = mass)
```

### [**Exercise 5**]{.hl-yellow}

üìù Select the 3 oldest characters.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_max(birth_year, n = 3)
```

### [**Exercise 6**]{.hl-yellow}

üìù To find out what unique values are in the hair color, remove duplicates of the `hair_color` variable by first removing the missing ones from the `hair_color` variable.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(hair_color) |> 
  distinct(hair_color)
```

### [**Exercise 7**]{.hl-yellow}

üìù Of the characters that are human and taller than 160 cm, eliminate duplicates in eye color, eliminate absent in weight, select the 3 tallest, and order from tallest to shortest in weight. Return the table.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Human" & height > 160) |> 
  distinct(eye_color, .keep_all = TRUE) |> 
  drop_na(mass) |> 
  slice_max(height, n = 3) |> 
  arrange(desc(mass))
```

:::

